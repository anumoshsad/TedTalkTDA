(dp0
S'transcript'
p1
(lp2
(lp3
VToday I'd like to show you
p4
aVthe future of the way we make things.
p5
aVI believe that soon our buildings and machines
p6
aVwill be self-assembling,
p7
aVreplicating and repairing themselves.
p8
aVSo I'm going to show you
p9
aVwhat I believe is the current state of manufacturing,
p10
aVand then compare that to some natural systems.
p11
aa(lp12
VSo in the current state of manufacturing, we have skyscrapers \u2014
p13
aVtwo and a half years [of assembly time],
p14
aV500,000 to a million parts,
p15
aVfairly complex,
p16
aVnew, exciting technologies in steel, concrete, glass.
p17
aVWe have exciting machines
p18
aVthat can take us into space \u2014
p19
aVfive years [of assembly time], 2.5 million parts.
p20
aa(lp21
VBut on the other side, if you look at the natural systems,
p22
aVwe have proteins
p23
aVthat have two million types,
p24
aVcan fold in 10,000 nanoseconds,
p25
aVor DNA with three billion base pairs
p26
aVwe can replicate in roughly an hour.
p27
aVSo there's all of this complexity
p28
aVin our natural systems,
p29
aVbut they're extremely efficient,
p30
aVfar more efficient than anything we can build,
p31
aVfar more complex than anything we can build.
p32
aVThey're far more efficient in terms of energy.
p33
aVThey hardly ever make mistakes.
p34
aVAnd they can repair themselves for longevity.
p35
aa(lp36
VSo there's something super interesting about natural systems.
p37
aVAnd if we can translate that
p38
aVinto our built environment,
p39
aVthen there's some exciting potential for the way that we build things.
p40
aVAnd I think the key to that is self-assembly.
p41
aa(lp42
VSo if we want to utilize self-assembly in our physical environment,
p43
aVI think there's four key factors.
p44
aVThe first is that we need to decode
p45
aVall of the complexity of what we want to build \u2014
p46
aVso our buildings and machines.
p47
aVAnd we need to decode that into simple sequences \u2014
p48
aVbasically the DNA of how our buildings work.
p49
aVThen we need programmable parts
p50
aVthat can take that sequence
p51
aVand use that to fold up, or reconfigure.
p52
aVWe need some energy that's going to allow that to activate,
p53
aVallow our parts to be able to fold up from the program.
p54
aVAnd we need some type of error correction redundancy
p55
aVto guarantee that we have successfully built what we want.
p56
aa(lp57
VSo I'm going to show you a number of projects
p58
aVthat my colleagues and I at MIT are working on
p59
aVto achieve this self-assembling future.
p60
aVThe first two are the MacroBot and DeciBot.
p61
aVSo these projects are large-scale reconfigurable robots \u2014
p62
aV8 ft., 12 ft. long proteins.
p63
aVThey're embedded with mechanical electrical devices, sensors.
p64
aVYou decode what you want to fold up into,
p65
aVinto a sequence of angles \u2014
p66
aVso negative 120, negative 120, 0, 0,
p67
aV120, negative 120 \u2014 something like that;
p68
aVso a sequence of angles, or turns,
p69
aVand you send that sequence through the string.
p70
aVEach unit takes its message \u2014 so negative 120 \u2014
p71
aVit rotates to that, checks if it got there
p72
aVand then passes it to its neighbor.
p73
aa(lp74
VSo these are the brilliant scientists,
p75
aVengineers, designers that worked on this project.
p76
aVAnd I think it really brings to light:
p77
aVIs this really scalable?
p78
aVI mean, thousands of dollars, lots of man hours
p79
aVmade to make this eight-foot robot.
p80
aVCan we really scale this up? Can we really embed robotics into every part?
p81
aVThe next one questions that
p82
aVand looks at passive nature,
p83
aVor passively trying to have reconfiguration programmability.
p84
aVBut it goes a step further,
p85
aVand it tries to have actual computation.
p86
aVIt basically embeds the most fundamental building block of computing,
p87
aVthe digital logic gate,
p88
aVdirectly into your parts.
p89
aa(lp90
VSo this is a NAND gate.
p91
aVYou have one tetrahedron which is the gate
p92
aVthat's going to do your computing,
p93
aVand you have two input tetrahedrons.
p94
aVOne of them is the input from the user, as you're building your bricks.
p95
aVThe other one is from the previous brick that was placed.
p96
aVAnd then it gives you an output in 3D space.
p97
aVSo what this means
p98
aVis that the user can start plugging in what they want the bricks to do.
p99
aVIt computes on what it was doing before
p100
aVand what you said you wanted it to do.
p101
aVAnd now it starts moving in three-dimensional space \u2014
p102
aVso up or down.
p103
aVSo on the left-hand side, [1,1] input equals 0 output, which goes down.
p104
aVOn the right-hand side,
p105
aV[0,0] input is a 1 output, which goes up.
p106
aVAnd so what that really means
p107
aVis that our structures now contain the blueprints
p108
aVof what we want to build.
p109
aa(lp110
VSo they have all of the information embedded in them of what was constructed.
p111
aVSo that means that we can have some form of self-replication.
p112
aVIn this case I call it self-guided replication,
p113
aVbecause your structure contains the exact blueprints.
p114
aVIf you have errors, you can replace a part.
p115
aVAll the local information is embedded to tell you how to fix it.
p116
aVSo you could have something that climbs along and reads it
p117
aVand can output at one to one.
p118
aVIt's directly embedded; there's no external instructions.
p119
aa(lp120
VSo the last project I'll show is called Biased Chains,
p121
aVand it's probably the most exciting example that we have right now
p122
aVof passive self-assembly systems.
p123
aVSo it takes the reconfigurability
p124
aVand programmability
p125
aVand makes it a completely passive system.
p126
aVSo basically you have a chain of elements.
p127
aVEach element is completely identical,
p128
aVand they're biased.
p129
aVSo each chain, or each element, wants to turn right or left.
p130
aVSo as you assemble the chain, you're basically programming it.
p131
aVYou're telling each unit if it should turn right or left.
p132
aVSo when you shake the chain,
p133
aVit then folds up
p134
aVinto any configuration that you've programmed in \u2014
p135
aVso in this case, a spiral,
p136
aVor in this case,
p137
aVtwo cubes next to each other.
p138
aVSo you can basically program
p139
aVany three-dimensional shape \u2014
p140
aVor one-dimensional, two-dimensional \u2014 up into this chain completely passively.
p141
aa(lp142
VSo what does this tell us about the future?
p143
aVI think that it's telling us
p144
aVthat there's new possibilities for self-assembly, replication, repair
p145
aVin our physical structures, our buildings, machines.
p146
aVThere's new programmability in these parts.
p147
aVAnd from that you have new possibilities for computing.
p148
aVWe'll have spatial computing.
p149
aVImagine if our buildings, our bridges, machines,
p150
aVall of our bricks could actually compute.
p151
aVThat's amazing parallel and distributed computing power,
p152
aVnew design possibilities.
p153
aVSo it's exciting potential for this.
p154
aVSo I think these projects I've showed here
p155
aVare just a tiny step towards this future,
p156
aVif we implement these new technologies
p157
aVfor a new self-assembling world.
p158
aa(lp159
VThank you.
p160
aa(lp161
V(Applause)
p162
aasS'id'
p163
I1215
sS'title'
p164
VCan we make things that make themselves?
p165
s.